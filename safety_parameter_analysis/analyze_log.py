#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Simulation Log Analysis Script
==============================

This script reads a simulation log file generated by `zmq_dds_sim.py --log`,
and performs a detailed analysis to help tune the safety layer parameters.

Key Features:
- **Automatic Log Loading**: Loads the most recent log file by default.
- **Safety Layer Simulation**: Re-evaluates safety constraints for each logged timestep
  to identify when and why safety limits would be triggered.
- **Comprehensive Visualization**: Generates plots for each joint, showing:
    - Position vs. time (with safety limits).
    - Velocity vs. time.
    - Applied Torque vs. time (with safety limits).
    - PD Position Target vs. time.
- **Statistical Summary**: Calculates and displays key statistics (min, max, mean) for
  critical metrics like position error and torque.
- **Actionable Insights**: Pinpoints specific joints and timestamps that breach safety
  thresholds, providing the data needed to adjust parameters reasonably.

Usage:
    # Analyze the most recent log file
    python analyze_log.py

    # Analyze a specific log file
    python analyze_log.py --file logs/sim_log_YYYYMMDD_HHMMSS.pkl
"""

import argparse
import pickle
import numpy as np
import matplotlib.pyplot as plt
import os
import glob
import mujoco
from typing import Dict, Any, List, Tuple, Optional
import json

# To import the safety layer and robot config, we need to adjust the path
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from sdk_controller.abstract_biped import HGSafetyLayer
from sdk_controller.robots.G1 import NUM_ACTIVE_BODY_JOINTS, MUJOCO_JOINT_NAMES, WAIST_KP, Kd


def load_global_config():
    """Load global configuration from JSON file"""
    config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "global_config.json")
    with open(config_path, 'r') as f:
        return json.load(f)


class LogAnalyzer:
    """Analyzes a simulation log file."""

    def __init__(self, log_data: Dict[str, Any]):
        self.log_data = log_data
        self.metadata = self.log_data['metadata']
        self.global_config = load_global_config()
        print("✅ Log data loaded successfully.")
        print(f"   Timestamp: {self.metadata['timestamp']}")
        print(f"   Mode: {self.metadata['mode']}")

        # Load MuJoCo model
        self.mj_model = mujoco.MjModel.from_xml_path("g1_model/scene.xml")
        
        # Instantiate the same safety layer used in the controller
        # For this analysis, we can choose which mode to test
        self.safety_layer_default = HGSafetyLayer(self.mj_model, conservative_safety=False)
        self.safety_layer_conservative = HGSafetyLayer(self.mj_model, conservative_safety=True)
        
        # Pre-process data
        self._unpack_data()

    def _unpack_data(self):
        """Unpack per-cycle data into NumPy arrays."""
        data = self.log_data['data_per_cycle']
        if not data:
            print("⚠️ No per-cycle data found in the log.")
            self.time = np.array([])
            return

        self.time = np.array([d['time'] for d in data])
        self.qpos = np.array([d['qpos'] for d in data])
        self.qvel = np.array([d['qvel'] for d in data])
        self.qacc = np.array([d['qacc'] for d in data])
        self.actuator_force = np.array([d['actuator_force'] for d in data])
        # The PD targets can be a sequence, we take the first one as the primary target for the cycle
        self.pd_targets = np.array([d['pd_targets'][0] for d in data if len(d['pd_targets']) > 0])
        
        # Ensure pd_targets has the correct length if a cycle had no targets
        if len(self.pd_targets) != len(self.time):
            print(f"Warning: Mismatch in length of pd_targets ({len(self.pd_targets)}) and time ({len(self.time)}). Padding with last known value.")
            
            # Create a full-size array and fill it
            full_pd_targets = np.zeros((len(self.time), self.pd_targets.shape[1]))
            pd_idx = 0
            for i in range(len(self.time)):
                if pd_idx < len(self.pd_targets):
                     full_pd_targets[i] = self.pd_targets[pd_idx]
                else: # If we run out of targets, repeat the last one
                     full_pd_targets[i] = self.pd_targets[-1]
                
                # Assume one pd_target packet per timestamp
                if i+1 < len(self.time) and self.time[i+1] > self.time[i]:
                    pd_idx += 1
            self.pd_targets = full_pd_targets


    def _get_kp_gains(self, kp_scale_factor: float = 1.0) -> np.ndarray:
        """
        Get Kp gains from global configuration.
        """
        gains = np.zeros(NUM_ACTIVE_BODY_JOINTS)
        joint_config = self.global_config["g1_joint_config"]
        
        for joint_name, config in joint_config.items():
            mj_idx = config["mujoco_index"]
            if mj_idx < NUM_ACTIVE_BODY_JOINTS:
                gains[mj_idx] = config["kp"] * kp_scale_factor
                
        return gains

    def run_safety_analysis(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Iterates through the log and checks for safety violations at each step.
        """
        print("\n--- Running Safety Analysis ---")
        if self.time.size == 0:
            print("No data to analyze.")
            return {}

        kp_gains = self._get_kp_gains() # Assume kp_scale_factor=1.0 for analysis
        violations = {'default': [], 'conservative': []}
        
        for i in range(len(self.time)):
            q_current = self.qpos[i][7 : 7 + NUM_ACTIVE_BODY_JOINTS]
            q_target = self.pd_targets[i][:NUM_ACTIVE_BODY_JOINTS]
            base_quat = self.qpos[i][3:7]
            actual_torques = self.actuator_force[i]
            
            # --- Check Default Safety Layer ---
            is_safe_default, reasons_default = self.safety_layer_default.check_safety_with_reasons(
                q_current, q_target, kp_gains, base_quat, actual_torques
            )
            if not is_safe_default:
                violations['default'].append({'time': self.time[i], 'reasons': reasons_default})

            # --- Check Conservative Safety Layer ---
            is_safe_conservative, reasons_conservative = self.safety_layer_conservative.check_safety_with_reasons(
                q_current, q_target, kp_gains, base_quat, actual_torques
            )
            if not is_safe_conservative:
                violations['conservative'].append({'time': self.time[i], 'reasons': reasons_conservative})
        
        print(f"Default Mode Violations: {len(violations['default'])} events")
        print(f"Conservative Mode Violations: {len(violations['conservative'])} events")
        print("-----------------------------")
        return violations

    def generate_plots(self, violations: Dict[str, List[Dict[str, Any]]]):
        """
        Generates and saves plots for each joint.
        """
        print("\n--- Generating Plots ---")
        output_dir = f"analysis_output/{self.metadata['timestamp']}"
        os.makedirs(output_dir, exist_ok=True)
        print(f"Plots will be saved in: {output_dir}")

        for joint_mj_idx in range(NUM_ACTIVE_BODY_JOINTS):
            joint_name = MUJOCO_JOINT_NAMES[joint_mj_idx]
            qpos_idx = 7 + joint_mj_idx
            qvel_idx = 6 + joint_mj_idx
            
            # Create a 4x2 subplot grid: 4 metrics, 2 modes (Default vs. Conservative)
            fig, axs = plt.subplots(4, 2, figsize=(25, 20), sharex=True)
            fig.suptitle(f"Analysis for Joint: {joint_name} (MuJoCo Index: {joint_mj_idx})", fontsize=18)

            # Set column titles
            axs[0, 0].set_title("Default Mode", fontsize=14)
            axs[0, 1].set_title("Conservative Mode", fontsize=14)

            # --- 1. Position Plot (Row 0) ---
            pos_ax_def, pos_ax_con = axs[0, 0], axs[0, 1]
            pos_ax_def.plot(self.time, self.qpos[:, qpos_idx], label='Actual Position')
            pos_ax_def.plot(self.time, self.pd_targets[:, joint_mj_idx], label='Target Position', linestyle='--')
            pos_ax_con.plot(self.time, self.qpos[:, qpos_idx], label='Actual Position')
            pos_ax_con.plot(self.time, self.pd_targets[:, joint_mj_idx], label='Target Position', linestyle='--')
            
            # Plot joint limits from each safety layer
            if joint_mj_idx in self.safety_layer_default.joint_limits:
                min_lim, max_lim = self.safety_layer_default.joint_limits[joint_mj_idx]
                pos_ax_def.axhline(y=min_lim, color='r', linestyle=':', label=f'Limit ({min_lim:.2f})')
                pos_ax_def.axhline(y=max_lim, color='r', linestyle=':')
            if joint_mj_idx in self.safety_layer_conservative.joint_limits:
                min_lim, max_lim = self.safety_layer_conservative.joint_limits[joint_mj_idx]
                pos_ax_con.axhline(y=min_lim, color='r', linestyle=':', label=f'Limit ({min_lim:.2f})')
                pos_ax_con.axhline(y=max_lim, color='r', linestyle=':')
            pos_ax_def.set_ylabel("Position (rad)")

            # --- 2. Velocity Plot (Row 1) ---
            vel_ax_def, vel_ax_con = axs[1, 0], axs[1, 1]
            vel_ax_def.plot(self.time, self.qvel[:, qvel_idx], label='Actual Velocity')
            vel_ax_con.plot(self.time, self.qvel[:, qvel_idx], label='Actual Velocity')
            vel_ax_def.set_ylabel("Velocity (rad/s)")
            
            # --- 3. Actuator Force/Torque Plot (Row 2) ---
            torque_ax_def, torque_ax_con = axs[2, 0], axs[2, 1]
            torque_ax_def.plot(self.time, self.actuator_force[:, joint_mj_idx], label='Actual Torque')
            torque_ax_con.plot(self.time, self.actuator_force[:, joint_mj_idx], label='Actual Torque')
            
            # Calculate and plot potential torque
            kp_gains = self._get_kp_gains()
            kp = kp_gains[joint_mj_idx]
            pos_error_for_torque = self.pd_targets[:, joint_mj_idx] - self.qpos[:, qpos_idx]
            potential_torque = kp * pos_error_for_torque
            
            torque_ax_def.plot(self.time, potential_torque, label='Potential Torque', linestyle='--', color='purple', alpha=0.8)
            torque_ax_con.plot(self.time, potential_torque, label='Potential Torque', linestyle='--', color='purple', alpha=0.8)

            # Get the correct DDS index for this joint
            joint_config = self.global_config["g1_joint_config"]
            dds_idx = joint_config[joint_name]["dds_index"]
            
            if dds_idx in self.safety_layer_default.torque_limits:
                max_torque = self.safety_layer_default.torque_limits[dds_idx]
                torque_ax_def.axhline(y=max_torque, color='r', linestyle=':', label=f'Torque Limit ({max_torque:.1f})')
                torque_ax_def.axhline(y=-max_torque, color='r', linestyle=':')
            if dds_idx in self.safety_layer_conservative.torque_limits:
                max_torque = self.safety_layer_conservative.torque_limits[dds_idx]
                torque_ax_con.axhline(y=max_torque, color='r', linestyle=':', label=f'Torque Limit ({max_torque:.1f})')
                torque_ax_con.axhline(y=-max_torque, color='r', linestyle=':')
            torque_ax_def.set_ylabel("Torque (Nm)")

            # --- 4. Position Error Plot (Row 3) ---
            error_ax_def, error_ax_con = axs[3, 0], axs[3, 1]
            pos_error = self.pd_targets[:, joint_mj_idx] - self.qpos[:, qpos_idx]
            error_ax_def.plot(self.time, pos_error, label='Position Error (target - actual)')
            error_ax_con.plot(self.time, pos_error, label='Position Error (target - actual)')

            max_err_def = self.safety_layer_default.max_position_error
            max_err_con = self.safety_layer_conservative.max_position_error
            error_ax_def.axhline(y=max_err_def, color='orange', linestyle=':', label=f'Error Limit ({max_err_def:.2f})')
            error_ax_def.axhline(y=-max_err_def, color='orange', linestyle=':')
            error_ax_con.axhline(y=max_err_con, color='red', linestyle=':', label=f'Error Limit ({max_err_con:.2f})')
            error_ax_con.axhline(y=-max_err_con, color='red', linestyle=':')
            error_ax_def.set_ylabel("Position Error (rad)")
            
            # --- Add violation markers and finalize plots ---
            
            # Get unique violation times for this joint
            default_violation_times = sorted(list(set(
                v['time'] for v in violations['default']
                for r in v['reasons']
                if r.get('joint_name') == joint_name or r.get('actuator_name') == joint_name
            )))

            conservative_violation_times = sorted(list(set(
                v['time'] for v in violations['conservative']
                for r in v['reasons']
                if r.get('joint_name') == joint_name or r.get('actuator_name') == joint_name
            )))

            if self.time.size > 1:
                time_to_idx = {t: i for i, t in enumerate(self.time)}
                
                # Plot conservative violations (red) on the RIGHT column
                for t in conservative_violation_times:
                    if t in time_to_idx:
                        idx = time_to_idx[t]
                        start_time = self.time[idx]
                        end_time = self.time[idx + 1] if idx + 1 < len(self.time) else start_time + (self.time[idx] - self.time[idx - 1])
                        for i in range(4):
                            axs[i, 1].axvspan(start_time, end_time, color='red', alpha=0.3, linewidth=0)

                # Plot default violations (orange) on the LEFT column
                for t in default_violation_times:
                    if t in time_to_idx:
                        idx = time_to_idx[t]
                        start_time = self.time[idx]
                        end_time = self.time[idx + 1] if idx + 1 < len(self.time) else start_time + (self.time[idx] - self.time[idx - 1])
                        for i in range(4):
                            axs[i, 0].axvspan(start_time, end_time, color='orange', alpha=0.3, linewidth=0)
            
            import matplotlib.patches as mpatches
            for i in range(4):
                # Left (Default) column
                h_d, l_d = axs[i, 0].get_legend_handles_labels()
                if default_violation_times:
                    h_d.append(mpatches.Patch(color='orange', alpha=0.3, label='Default Violation'))
                axs[i, 0].legend(handles=h_d)
                axs[i, 0].grid(True)

                # Right (Conservative) column
                h_c, l_c = axs[i, 1].get_legend_handles_labels()
                if conservative_violation_times:
                    h_c.append(mpatches.Patch(color='red', alpha=0.3, label='Conservative Violation'))
                axs[i, 1].legend(handles=h_c)
                axs[i, 1].grid(True)
            
            axs[3, 0].set_xlabel("Time (s)")
            axs[3, 1].set_xlabel("Time (s)")

            plt.tight_layout(rect=[0, 0.03, 1, 0.97])
            plt.savefig(f"{output_dir}/{joint_mj_idx:02d}_{joint_name}.png")
            plt.close()
        
        print(f"✅ All joint plots have been saved.")

    def print_summary_report(self, violations: Dict[str, List[Dict[str, Any]]]):
        """Prints a summary of the analysis."""
        print("\n--- Detailed Violation Log (Max 5 per type) ---")
        print_counts = {}
        joint_name_to_idx = {name: i for i, name in enumerate(MUJOCO_JOINT_NAMES)}

        # Prioritize printing default mode violations first
        modes_to_print = ['default', 'conservative']
        for mode in modes_to_print:
            v_events = violations.get(mode, [])
            for v_event in v_events:
                for reason in v_event['reasons']:
                    joint_name = reason.get('joint_name') or reason.get('actuator_name') or 'Base'
                    reason_type = reason['type']
                    
                    key = (joint_name, mode, reason_type)
                    count = print_counts.get(key, 0)

                    if count < 5:
                        idx = joint_name_to_idx.get(joint_name, 'N/A')
                        value = reason.get('value', 'N/A')
                        limit = reason.get('limit', 'N/A')
                        time = v_event['time']

                        # Format value and limit for clean printing
                        value_str = f"{value:.3f}" if isinstance(value, (int, float)) else str(value)
                        limit_str = f"{limit:.3f}" if isinstance(limit, (int, float)) else str(limit)
                        
                        print(f"ERROR: Joint {idx} ({joint_name}) | {mode.upper()} | {reason_type} violated at t={time:.2f}s, because Value {value_str} > Limit {limit_str}")
                        
                        print_counts[key] = count + 1

        print("\n--- Analysis Summary Report ---")
        
        # Print violation details
        for mode, v_events in violations.items():
            if not v_events:
                print(f"\n✅ No safety violations detected in [{mode.upper()}] mode.")
                continue
            
            print(f"\n🚨 Found {len(v_events)} safety violation events in [{mode.upper()}] mode:")
            # Consolidate reasons
            reason_counts = {}
            for v_event in v_events:
                for reason in v_event['reasons']:
                    key = f"{reason['type']} on {reason.get('joint_name') or reason.get('actuator_name') or 'Base'}"
                    reason_counts[key] = reason_counts.get(key, 0) + 1
            
            for reason, count in sorted(reason_counts.items()):
                print(f"  - {reason}: {count} times")

        # Print statistics for key metrics
        print("\n--- Key Metric Statistics ---")
        pos_error = self.pd_targets[:, :NUM_ACTIVE_BODY_JOINTS] - self.qpos[:, 7:7+NUM_ACTIVE_BODY_JOINTS]
        
        print("\nMax Absolute Position Error (rad):")
        max_errors = np.max(np.abs(pos_error), axis=0)
        for i in range(NUM_ACTIVE_BODY_JOINTS):
            print(f"  - {MUJOCO_JOINT_NAMES[i]:<20}: {max_errors[i]:.4f}")

        print("\nMax Absolute Torque (Nm):")
        max_torques = np.max(np.abs(self.actuator_force), axis=0)
        for i in range(NUM_ACTIVE_BODY_JOINTS):
            print(f"  - {MUJOCO_JOINT_NAMES[i]:<20}: {max_torques[i]:.4f}")
        
        print("\n--- End of Report ---")


def find_latest_log_file(log_dir: str = "logs") -> Optional[str]:
    """Finds the most recent .pkl log file in a directory."""
    if not os.path.isdir(log_dir):
        return None
    list_of_files = glob.glob(f'{log_dir}/*.pkl')
    if not list_of_files:
        return None
    latest_file = max(list_of_files, key=os.path.getctime)
    return latest_file


def main():
    parser = argparse.ArgumentParser(description="Analyze a simulation log file.")
    parser.add_argument(
        "--file",
        type=str,
        default=None,
        help="Path to the .pkl log file to analyze. If not provided, the latest log in 'logs/' will be used."
    )
    args = parser.parse_args()

    log_file = args.file
    if log_file is None:
        print("No file specified, searching for the latest log in 'logs/'...")
        log_file = find_latest_log_file()
    
    if log_file is None or not os.path.exists(log_file):
        print(f"❌ Error: Log file not found at '{log_file}'.")
        print("   Please run a simulation with the --log flag first.")
        sys.exit(1)
        
    print(f"🔍 Analyzing log file: {log_file}")
    
    with open(log_file, 'rb') as f:
        log_data = pickle.load(f)
        
    analyzer = LogAnalyzer(log_data)

    # To run the safety analysis, the safety layer needs a way to return reasons.
    # We will monkey-patch the HGSafetyLayer for this analysis script.
    
    def check_safety_with_reasons(self, q_current, q_target, kp_gains, base_quaternion, actual_torques) -> Tuple[bool, List[Dict]]:
        """Analysis-specific version that returns detailed reasons for failure."""
        reasons = []
        
        # 1. Base orientation check
        if not self.check_base_orientation(base_quaternion):
            # This check prints but doesn't return structured data. Let's replicate the logic.
            _, x, y, z = base_quaternion
            roll = np.arctan2(2 * (y * z + x), 1 - 2 * (x ** 2 + y ** 2))
            pitch = np.arcsin(2 * (x * z - y))
            reasons.append({
                'type': 'Base Orientation Limit', 
                'value': f'Roll={np.rad2deg(roll):.1f}, Pitch={np.rad2deg(pitch):.1f}',
                'limit': np.rad2deg(self.base_orientation_limit)
            })

        # 2. Joint position limits
        for joint_id, (q_min, q_max) in self.joint_limits.items():
            if not (q_min < q_current[joint_id] < q_max):
                reasons.append({
                    'type': 'Joint Position Limit',
                    'joint_name': MUJOCO_JOINT_NAMES[joint_id],
                    'value': q_current[joint_id],
                    'limit': (q_min, q_max)
                })

        # 3. Position error limits
        for mj_idx in range(len(q_current)):
            error = abs(q_target[mj_idx] - q_current[mj_idx])
            if error > self.max_position_error:
                reasons.append({
                    'type': 'Position Error Limit',
                    'joint_name': MUJOCO_JOINT_NAMES[mj_idx],
                    'value': error,
                    'limit': self.max_position_error
                })
        
        # 4. Potential torque limits
        for mj_idx, dds_idx in self.BODY_MUJOCO_TO_DDS.items():
            if (mj_idx < len(q_current) and dds_idx in self.torque_limits):
                potential_torque = abs(kp_gains[mj_idx] * (q_target[mj_idx] - q_current[mj_idx]))
                if potential_torque > self.torque_limits[dds_idx]:
                    reasons.append({
                        'type': 'Potential Torque Limit',
                        'joint_name': MUJOCO_JOINT_NAMES[mj_idx],
                        'value': potential_torque,
                        'limit': self.torque_limits[dds_idx]
                    })
        
        # 5. Actual Torque Limits (from logged actuator_force)
        for dds_idx, max_torque in self.torque_limits.items():
            # Find the corresponding MuJoCo index for the DDS index
            mj_idx_for_torque = -1
            for mj, dds in self.BODY_MUJOCO_TO_DDS.items():
                if dds == dds_idx:
                    mj_idx_for_torque = mj
                    break
            
            if mj_idx_for_torque != -1 and mj_idx_for_torque < len(actual_torques):
                torque_val = actual_torques[mj_idx_for_torque]
                if abs(torque_val) > max_torque:
                     reasons.append({
                        'type': 'Actual Torque Limit',
                        'joint_name': MUJOCO_JOINT_NAMES[mj_idx_for_torque],
                        'value': abs(torque_val),
                        'limit': max_torque
                    })

        return not bool(reasons), reasons

    # Monkey-patch the method onto the class for this run
    HGSafetyLayer.check_safety_with_reasons = check_safety_with_reasons
    # The safety layer also needs access to this mapping
    from sdk_controller.robots.G1 import BODY_MUJOCO_TO_DDS
    HGSafetyLayer.BODY_MUJOCO_TO_DDS = BODY_MUJOCO_TO_DDS


    violations = analyzer.run_safety_analysis()
    analyzer.print_summary_report(violations)
    analyzer.generate_plots(violations)


if __name__ == "__main__":
    main() 