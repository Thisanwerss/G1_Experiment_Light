#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Simulation Log Analysis Script
==============================

This script reads a simulation log file generated by `zmq_dds_sim.py --log`,
and performs a detailed analysis to help tune the safety layer parameters.

Key Features:
- **Automatic Log Loading**: Loads the most recent log file by default.
- **Safety Layer Simulation**: Re-evaluates safety constraints for each logged timestep
  to identify when and why safety limits would be triggered.
- **Comprehensive Visualization**: Generates plots for each joint, showing:
    - Position vs. time (with safety limits).
    - Velocity vs. time.
    - Applied Torque vs. time (with safety limits).
    - PD Position Target vs. time.
- **Statistical Summary**: Calculates and displays key statistics (min, max, mean) for
  critical metrics like position error and torque.
- **Actionable Insights**: Pinpoints specific joints and timestamps that breach safety
  thresholds, providing the data needed to adjust parameters reasonably.

Usage:
    # Analyze the most recent log file
    python analyze_log.py

    # Analyze a specific log file
    python analyze_log.py --file logs/sim_log_YYYYMMDD_HHMMSS.pkl
"""

import argparse
import pickle
import numpy as np
import matplotlib.pyplot as plt
import os
import glob
import mujoco
from typing import Dict, Any, List, Tuple, Optional

# To import the safety layer and robot config, we need to adjust the path
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from sdk_controller.abstract_biped import HGSafetyLayer
from sdk_controller.robots.G1 import NUM_ACTIVE_BODY_JOINTS, MUJOCO_JOINT_NAMES, WAIST_KP, Kd



class LogAnalyzer:
    """Analyzes a simulation log file."""

    def __init__(self, log_data: Dict[str, Any]):
        self.log_data = log_data
        self.metadata = self.log_data['metadata']
        print("✅ Log data loaded successfully.")
        print(f"   Timestamp: {self.metadata['timestamp']}")
        print(f"   Mode: {self.metadata['mode']}")

        # Load MuJoCo model
        self.mj_model = mujoco.MjModel.from_xml_path("g1_model/scene.xml")
        
        # Instantiate the same safety layer used in the controller
        # For this analysis, we can choose which mode to test
        self.safety_layer_default = HGSafetyLayer(self.mj_model, conservative_safety=False)
        self.safety_layer_conservative = HGSafetyLayer(self.mj_model, conservative_safety=True)
        
        # Pre-process data
        self._unpack_data()

    def _unpack_data(self):
        """Unpack per-cycle data into NumPy arrays."""
        data = self.log_data['data_per_cycle']
        if not data:
            print("⚠️ No per-cycle data found in the log.")
            self.time = np.array([])
            return

        self.time = np.array([d['time'] for d in data])
        self.qpos = np.array([d['qpos'] for d in data])
        self.qvel = np.array([d['qvel'] for d in data])
        self.qacc = np.array([d['qacc'] for d in data])
        self.actuator_force = np.array([d['actuator_force'] for d in data])
        # The PD targets can be a sequence, we take the first one as the primary target for the cycle
        self.pd_targets = np.array([d['pd_targets'][0] for d in data if len(d['pd_targets']) > 0])
        
        # Ensure pd_targets has the correct length if a cycle had no targets
        if len(self.pd_targets) != len(self.time):
            print(f"Warning: Mismatch in length of pd_targets ({len(self.pd_targets)}) and time ({len(self.time)}). Padding with last known value.")
            
            # Create a full-size array and fill it
            full_pd_targets = np.zeros((len(self.time), self.pd_targets.shape[1]))
            pd_idx = 0
            for i in range(len(self.time)):
                if pd_idx < len(self.pd_targets):
                     full_pd_targets[i] = self.pd_targets[pd_idx]
                else: # If we run out of targets, repeat the last one
                     full_pd_targets[i] = self.pd_targets[-1]
                
                # Assume one pd_target packet per timestamp
                if i+1 < len(self.time) and self.time[i+1] > self.time[i]:
                    pd_idx += 1
            self.pd_targets = full_pd_targets


    def _get_kp_gains(self, kp_scale_factor: float = 1.0) -> np.ndarray:
        """
        Replicates the Kp gain calculation from the controller.
        This is necessary to simulate the safety layer's potential torque checks.
        """
        gains = np.zeros(NUM_ACTIVE_BODY_JOINTS)
        for mj_idx in range(NUM_ACTIVE_BODY_JOINTS):
            kp = 0.0
            if mj_idx < 12:  # leg joints
                if mj_idx % 6 in [0, 1, 2]: kp = 60.0   # hip
                elif mj_idx % 6 == 3: kp = 100.0        # knee
                else: kp = 40.0                         # ankle
            elif mj_idx == 12: kp = WAIST_KP             # waist
            else:  # arm joints
                if mj_idx <= 19 or (mj_idx >= 22 and mj_idx <=25) : kp = 40.0 # shoulder/elbow
                else: kp = 20.0 # wrist
            gains[mj_idx] = kp * kp_scale_factor
        return gains

    def run_safety_analysis(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Iterates through the log and checks for safety violations at each step.
        """
        print("\n--- Running Safety Analysis ---")
        if self.time.size == 0:
            print("No data to analyze.")
            return {}

        kp_gains = self._get_kp_gains() # Assume kp_scale_factor=1.0 for analysis
        violations = {'default': [], 'conservative': []}
        
        for i in range(len(self.time)):
            q_current = self.qpos[i][7 : 7 + NUM_ACTIVE_BODY_JOINTS]
            q_target = self.pd_targets[i][:NUM_ACTIVE_BODY_JOINTS]
            base_quat = self.qpos[i][3:7]
            actual_torques = self.actuator_force[i]
            
            # --- Check Default Safety Layer ---
            is_safe_default, reasons_default = self.safety_layer_default.check_safety_with_reasons(
                q_current, q_target, kp_gains, base_quat, actual_torques
            )
            if not is_safe_default:
                violations['default'].append({'time': self.time[i], 'reasons': reasons_default})

            # --- Check Conservative Safety Layer ---
            is_safe_conservative, reasons_conservative = self.safety_layer_conservative.check_safety_with_reasons(
                q_current, q_target, kp_gains, base_quat, actual_torques
            )
            if not is_safe_conservative:
                violations['conservative'].append({'time': self.time[i], 'reasons': reasons_conservative})
        
        print(f"Default Mode Violations: {len(violations['default'])} events")
        print(f"Conservative Mode Violations: {len(violations['conservative'])} events")
        print("-----------------------------")
        return violations

    def generate_plots(self, violations: Dict[str, List[Dict[str, Any]]]):
        """
        Generates and saves plots for each joint.
        """
        print("\n--- Generating Plots ---")
        output_dir = f"analysis_output/{self.metadata['timestamp']}"
        os.makedirs(output_dir, exist_ok=True)
        print(f"Plots will be saved in: {output_dir}")

        for joint_mj_idx in range(NUM_ACTIVE_BODY_JOINTS):
            joint_name = MUJOCO_JOINT_NAMES[joint_mj_idx]
            qpos_idx = 7 + joint_mj_idx
            qvel_idx = 6 + joint_mj_idx
            
            fig, axs = plt.subplots(4, 1, figsize=(15, 20), sharex=True)
            fig.suptitle(f"Analysis for Joint: {joint_name} (MuJoCo Index: {joint_mj_idx})", fontsize=16)

            # 1. Position Plot
            axs[0].plot(self.time, self.qpos[:, qpos_idx], label='Actual Position (qpos)')
            axs[0].plot(self.time, self.pd_targets[:, joint_mj_idx], label='Target Position (PD)', linestyle='--')
            # Plot joint limits from safety layer
            if joint_mj_idx in self.safety_layer_default.joint_limits:
                min_lim, max_lim = self.safety_layer_default.joint_limits[joint_mj_idx]
                axs[0].axhline(y=min_lim, color='r', linestyle=':', label=f'Joint Limit (Default: {min_lim:.2f})')
                axs[0].axhline(y=max_lim, color='r', linestyle=':', label=f'Joint Limit (Default: {max_lim:.2f})')
            axs[0].set_ylabel("Position (rad)")
            axs[0].legend()
            axs[0].grid(True)
            
            # 2. Velocity Plot
            axs[1].plot(self.time, self.qvel[:, qvel_idx], label='Actual Velocity (qvel)')
            axs[1].set_ylabel("Velocity (rad/s)")
            axs[1].legend()
            axs[1].grid(True)
            
            # 3. Actuator Force/Torque Plot
            axs[2].plot(self.time, self.actuator_force[:, joint_mj_idx], label='Actual Torque')
            # Plot torque limits
            # Note: torque limits are mapped by DDS id, need to find it.
            # This is complex, so for now we check potential torque instead. A simple placeholder:
            act_id = joint_mj_idx # In our case mj_idx and act_id are the same for body joints
            if act_id in self.safety_layer_default.torque_limits:
                max_torque = self.safety_layer_default.torque_limits[act_id]
                axs[2].axhline(y=max_torque, color='r', linestyle=':', label=f'Torque Limit (Default: {max_torque:.1f})')
                axs[2].axhline(y=-max_torque, color='r', linestyle=':')
            axs[2].set_ylabel("Torque (Nm)")
            axs[2].legend()
            axs[2].grid(True)

            # 4. Position Error Plot
            pos_error = self.pd_targets[:, joint_mj_idx] - self.qpos[:, qpos_idx]
            axs[3].plot(self.time, pos_error, label='Position Error (target - actual)')
            # Plot error limits
            max_err_def = self.safety_layer_default.max_position_error
            max_err_con = self.safety_layer_conservative.max_position_error
            axs[3].axhline(y=max_err_def, color='orange', linestyle=':', label=f'Error Limit (Default: {max_err_def:.2f})')
            axs[3].axhline(y=-max_err_def, color='orange', linestyle=':')
            axs[3].axhline(y=max_err_con, color='red', linestyle=':', label=f'Error Limit (Conservative: {max_err_con:.2f})')
            axs[3].axhline(y=-max_err_con, color='red', linestyle=':')
            axs[3].set_ylabel("Position Error (rad)")
            axs[3].set_xlabel("Time (s)")
            axs[3].legend()
            axs[3].grid(True)
            
            # Add violation markers
            for v_event in violations['default']:
                for reason in v_event['reasons']:
                    if reason.get('joint_name') == joint_name or reason.get('actuator_name') == joint_name:
                        axs[0].axvline(x=v_event['time'], color='orange', linestyle='--', alpha=0.7)
                        axs[1].axvline(x=v_event['time'], color='orange', linestyle='--', alpha=0.7)
                        axs[2].axvline(x=v_event['time'], color='orange', linestyle='--', alpha=0.7)
                        axs[3].axvline(x=v_event['time'], color='orange', linestyle='--', alpha=0.7)

            plt.tight_layout(rect=[0, 0, 1, 0.96])
            plt.savefig(f"{output_dir}/{joint_mj_idx:02d}_{joint_name}.png")
            plt.close()
        
        print(f"✅ All joint plots have been saved.")

    def print_summary_report(self, violations: Dict[str, List[Dict[str, Any]]]):
        """Prints a summary of the analysis."""
        print("\n--- Analysis Summary Report ---")
        
        # Print violation details
        for mode, v_events in violations.items():
            if not v_events:
                print(f"\n✅ No safety violations detected in [{mode.upper()}] mode.")
                continue
            
            print(f"\n🚨 Found {len(v_events)} safety violation events in [{mode.upper()}] mode:")
            # Consolidate reasons
            reason_counts = {}
            for v_event in v_events:
                for reason in v_event['reasons']:
                    key = f"{reason['type']} on {reason.get('joint_name') or reason.get('actuator_name') or 'Base'}"
                    reason_counts[key] = reason_counts.get(key, 0) + 1
            
            for reason, count in sorted(reason_counts.items()):
                print(f"  - {reason}: {count} times")

        # Print statistics for key metrics
        print("\n--- Key Metric Statistics ---")
        pos_error = self.pd_targets[:, :NUM_ACTIVE_BODY_JOINTS] - self.qpos[:, 7:7+NUM_ACTIVE_BODY_JOINTS]
        
        print("\nMax Absolute Position Error (rad):")
        max_errors = np.max(np.abs(pos_error), axis=0)
        for i in range(NUM_ACTIVE_BODY_JOINTS):
            print(f"  - {MUJOCO_JOINT_NAMES[i]:<20}: {max_errors[i]:.4f}")

        print("\nMax Absolute Torque (Nm):")
        max_torques = np.max(np.abs(self.actuator_force), axis=0)
        for i in range(NUM_ACTIVE_BODY_JOINTS):
            print(f"  - {MUJOCO_JOINT_NAMES[i]:<20}: {max_torques[i]:.4f}")
        
        print("\n--- End of Report ---")


def find_latest_log_file(log_dir: str = "logs") -> Optional[str]:
    """Finds the most recent .pkl log file in a directory."""
    if not os.path.isdir(log_dir):
        return None
    list_of_files = glob.glob(f'{log_dir}/*.pkl')
    if not list_of_files:
        return None
    latest_file = max(list_of_files, key=os.path.getctime)
    return latest_file


def main():
    parser = argparse.ArgumentParser(description="Analyze a simulation log file.")
    parser.add_argument(
        "--file",
        type=str,
        default=None,
        help="Path to the .pkl log file to analyze. If not provided, the latest log in 'logs/' will be used."
    )
    args = parser.parse_args()

    log_file = args.file
    if log_file is None:
        print("No file specified, searching for the latest log in 'logs/'...")
        log_file = find_latest_log_file()
    
    if log_file is None or not os.path.exists(log_file):
        print(f"❌ Error: Log file not found at '{log_file}'.")
        print("   Please run a simulation with the --log flag first.")
        sys.exit(1)
        
    print(f"🔍 Analyzing log file: {log_file}")
    
    with open(log_file, 'rb') as f:
        log_data = pickle.load(f)
        
    analyzer = LogAnalyzer(log_data)

    # To run the safety analysis, the safety layer needs a way to return reasons.
    # We will monkey-patch the HGSafetyLayer for this analysis script.
    
    def check_safety_with_reasons(self, q_current, q_target, kp_gains, base_quaternion, actual_torques) -> Tuple[bool, List[Dict]]:
        """Analysis-specific version that returns detailed reasons for failure."""
        reasons = []
        
        # 1. Base orientation check
        if not self.check_base_orientation(base_quaternion):
            # This check prints but doesn't return structured data. Let's replicate the logic.
            _, x, y, z = base_quaternion
            roll = np.arctan2(2 * (y * z + x), 1 - 2 * (x ** 2 + y ** 2))
            pitch = np.arcsin(2 * (x * z - y))
            reasons.append({
                'type': 'Base Orientation Limit', 
                'value': f'Roll={np.rad2deg(roll):.1f}, Pitch={np.rad2deg(pitch):.1f}',
                'limit': np.rad2deg(self.base_orientation_limit)
            })

        # 2. Joint position limits
        for joint_id, (q_min, q_max) in self.joint_limits.items():
            if not (q_min < q_current[joint_id] < q_max):
                reasons.append({
                    'type': 'Joint Position Limit',
                    'joint_name': MUJOCO_JOINT_NAMES[joint_id],
                    'value': q_current[joint_id],
                    'limit': (q_min, q_max)
                })

        # 3. Position error limits
        for mj_idx in range(len(q_current)):
            error = abs(q_target[mj_idx] - q_current[mj_idx])
            if error > self.max_position_error:
                reasons.append({
                    'type': 'Position Error Limit',
                    'joint_name': MUJOCO_JOINT_NAMES[mj_idx],
                    'value': error,
                    'limit': self.max_position_error
                })
        
        # 4. Potential torque limits
        for mj_idx, dds_idx in self.BODY_MUJOCO_TO_DDS.items():
            if (mj_idx < len(q_current) and dds_idx in self.torque_limits):
                potential_torque = abs(kp_gains[mj_idx] * (q_target[mj_idx] - q_current[mj_idx]))
                if potential_torque > self.torque_limits[dds_idx]:
                    reasons.append({
                        'type': 'Potential Torque Limit',
                        'joint_name': MUJOCO_JOINT_NAMES[mj_idx],
                        'value': potential_torque,
                        'limit': self.torque_limits[dds_idx]
                    })
        
        # 5. Actual Torque Limits (from logged actuator_force)
        for dds_idx, max_torque in self.torque_limits.items():
            # Find the corresponding MuJoCo index for the DDS index
            mj_idx_for_torque = -1
            for mj, dds in self.BODY_MUJOCO_TO_DDS.items():
                if dds == dds_idx:
                    mj_idx_for_torque = mj
                    break
            
            if mj_idx_for_torque != -1 and mj_idx_for_torque < len(actual_torques):
                torque_val = actual_torques[mj_idx_for_torque]
                if abs(torque_val) > max_torque:
                     reasons.append({
                        'type': 'Actual Torque Limit',
                        'joint_name': MUJOCO_JOINT_NAMES[mj_idx_for_torque],
                        'value': abs(torque_val),
                        'limit': max_torque
                    })

        return not bool(reasons), reasons

    # Monkey-patch the method onto the class for this run
    HGSafetyLayer.check_safety_with_reasons = check_safety_with_reasons
    # The safety layer also needs access to this mapping
    from sdk_controller.robots.G1 import BODY_MUJOCO_TO_DDS
    HGSafetyLayer.BODY_MUJOCO_TO_DDS = BODY_MUJOCO_TO_DDS


    violations = analyzer.run_safety_analysis()
    analyzer.print_summary_report(violations)
    analyzer.generate_plots(violations)


if __name__ == "__main__":
    main() 